<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 
<mapper namespace="gov.usgs.cida.gcmrcservices.mb.mappers.DurationCurveMapper">
	
	<resultMap id="durationCurveResult" type="DurationCurve">
		<result property="binNumber" column="BIN_NUMBER"/>
		<result property="cumulativeBinPerc" column="CUMULATIVE_BIN_PERC"/>
		<result property="binValue" column="BIN_VALUE"/>
		<result property="inBinMinutes" column="IN_BIN_MINUTES"/>
		<result property="cumulativeInBinMinutes" column="CUMULATIVE_IN_BIN_MINUTES"/>
		<result property="lowBound" column="LOW_BOUND"/>
		<result property="highBound" column="HIGH_BOUND"/>
	</resultMap>
	<select id="getDurationCurve" parameterType="map" resultMap="durationCurveResult">	
		SELECT
		   BIN_NUMBER   ,
		   CUMULATIVE_BIN_PERC   ,
		   BIN_VALUE   ,
		   IN_BIN_MINUTES   ,
		   CUMULATIVE_IN_BIN_MINUTES   ,
		   LOW_BOUND   ,
		   HIGH_BOUND  
		FROM(
		WITH CONST (DISCHARGE_MEASURE_ID, ONE_DAY_OF_MINUTES, DATA_GAP_MARKER, MAX_GAP_MINUTES, MAX_INTERPOLATION_DAYS, MIN_LOG_BIN_VALUE) AS
		 (
		  SELECT
			2 DISCHARGE_MEASURE_ID,
			60*24 ONE_DAY_OF_MINUTES,
			-999 DATA_GAP_MARKER, 
			60 MAX_GAP_MINUTES, 

			60 MAX_INTERPOLATION_DAYS,
			1 MIN_LOG_BIN_VALUE 
		  From DUAL
		), RAW_MTI_DATA (START_VALUE, END_VALUE, START_TIME, END_TIME, GAP_MINUTES) AS (
			SELECT
			START_VALUE,
			CASE WHEN END_VALUE = (SELECT DATA_GAP_MARKER FROM CONST) THEN LEAD(END_VALUE) OVER (ORDER BY START_TIME) ELSE END_VALUE END as END_VALUE,
			START_TIME,
			CASE WHEN END_VALUE = (SELECT DATA_GAP_MARKER FROM CONST) THEN LEAD(END_TIME) OVER (ORDER BY START_TIME) ELSE END_TIME END AS END_TIME,
			GAP_MINUTES 
		  FROM (
			SELECT * FROM ( 
			  SELECT

				START_VALUE,
				END_VALUE,
				START_TIME, 
				END_TIME,

				CASE
				  WHEN LEAD(START_VALUE) OVER (ORDER BY START_TIME) = (SELECT DATA_GAP_MARKER FROM CONST) AND LEAD(END_VALUE) OVER (ORDER BY START_TIME) = (SELECT DATA_GAP_MARKER FROM CONST)
					THEN EXTRACT(DAY FROM ((LEAD(END_TIME) OVER (ORDER BY START_TIME) - LEAD(END_TIME) OVER (ORDER BY START_TIME))*60*24))
				  ELSE 0
				END AS GAP_MINUTES
			  FROM (
				Select
				  FINAL_VALUE AS START_VALUE,
				  LEAD(FINAL_VALUE) OVER (ORDER BY MEASUREMENT_DATE) AS END_VALUE,
				  MEASUREMENT_DATE AS START_TIME, 
				  LEAD(MEASUREMENT_DATE) OVER (ORDER BY MEASUREMENT_DATE) AS END_TIME
				From TIME_SERIES_STAR
				Where 
				  SITE_ID=#{siteId, jdbcType=NUMERIC} 
				  And GROUP_ID= (SELECT DISCHARGE_MEASURE_ID FROM CONST) 

				  AND MEASUREMENT_DATE > (to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') - (SELECT MAX_INTERPOLATION_DAYS FROM CONST))
				  AND MEASUREMENT_DATE &lt; (to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') + (SELECT MAX_INTERPOLATION_DAYS FROM CONST))
			  )
			) WHERE
			  NOT (START_VALUE = (SELECT DATA_GAP_MARKER FROM CONST) AND END_VALUE = (SELECT DATA_GAP_MARKER FROM CONST)) 
		  )
		), CLEAN_MTI_DATA (START_VALUE, END_VALUE, MIN_VALUE, MAX_VALUE, START_TIME, END_TIME, DURATION_MINUTES, GAP_MINUTES, IS_START_INTERPOLATED, IS_END_INTERPOLATED) AS (
		  SELECT
			START_VALUE, END_VALUE, 
			LEAST(START_VALUE, END_VALUE) AS MIN_VALUE,
			GREATEST(START_VALUE, END_VALUE) AS MAX_VALUE,
			START_TIME,
			END_TIME,
			EXTRACT(DAY FROM ((END_TIME - START_TIME)*60*24)) AS DURATION_MINUTES,
			GAP_MINUTES, IS_START_INTERPOLATED, IS_END_INTERPOLATED 
		  FROM (
			SELECT
			  CASE
				WHEN START_TIME &lt; to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN
				START_VALUE + (EXTRACT(DAY FROM ((to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') - START_TIME) * (SELECT ONE_DAY_OF_MINUTES FROM CONST)))) * ((END_VALUE - START_VALUE)/(EXTRACT(DAY FROM ((END_TIME - START_TIME) * (SELECT ONE_DAY_OF_MINUTES FROM CONST)))))
				ELSE START_VALUE
			  END AS START_VALUE,
			  CASE
				WHEN END_TIME > to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN
				START_VALUE + (EXTRACT(DAY FROM ((to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') - START_TIME) * (SELECT ONE_DAY_OF_MINUTES FROM CONST)))) * ((END_VALUE - START_VALUE)/(EXTRACT(DAY FROM ((END_TIME - START_TIME) * (SELECT ONE_DAY_OF_MINUTES FROM CONST)))))
				ELSE END_VALUE
			  END AS END_VALUE,

			  CASE WHEN START_TIME &lt; to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') ELSE START_TIME END AS START_TIME,
			  CASE WHEN END_TIME > to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') ELSE END_TIME END AS END_TIME,
			  GAP_MINUTES,
			  CASE WHEN START_TIME &lt; to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN 1 ELSE 0 END AS IS_START_INTERPOLATED,
			  CASE WHEN END_TIME > to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') THEN 1 ELSE 0 END AS IS_END_INTERPOLATED
			FROM RAW_MTI_DATA
			WHERE
			  START_VALUE != (SELECT DATA_GAP_MARKER FROM CONST) 
			  AND END_TIME > to_timestamp(#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS')
			  AND START_TIME &lt; to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS')
			  AND NOT GAP_MINUTES > (SELECT MAX_GAP_MINUTES FROM CONST)
			  AND NOT EXTRACT(DAY FROM (END_TIME - START_TIME)) > (SELECT MAX_INTERPOLATION_DAYS FROM CONST)
			Order by START_TIME 
		  ) Order by START_TIME 
		), CONST_DATA (FIRST_MEASURE_DATE, LAST_MEASURE_DATE, OVERALL_DURATION_MINUTES, USER_DURATION_MINUTES, OVERALL_MIN_VALUE, OVERALL_MAX_VALUE, OVERALL_VALUE_RANGE, MEASUREMENT_COUNT) AS
		 (
		  SELECT
			MIN(START_TIME) as FIRST_MEASURE_DATE,
			MAX(END_TIME) as LAST_MEASURE_DATE,
			SUM(DURATION_MINUTES) as OVERALL_DURATION_MINUTES,
			EXTRACT(DAY FROM (to_timestamp(#{endTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS') - to_timestamp (#{startTime, jdbcType=CHAR}, 'YYYY-MM-DD"T"HH24:MI:SS'))*60*24) as USER_DURATION_MINUTES,
			MIN(MIN_VALUE) AS OVERALL_MIN_VALUE,
			MAX(MAX_VALUE) AS OVERALL_MAX_VALUE,
			MAX(MAX_VALUE) - MIN(MIN_VALUE) AS OVERALL_VALUE_RANGE,
			COUNT(*) AS MEASUREMENT_COUNT
		  From CLEAN_MTI_DATA
		), INT_BINS (BIN_NUMBER) AS
		(
		  SELECT level BIN_NUMBER   
		  FROM DUAL   
		  CONNECT BY level &lt;=#{binCount, jdbcType=NUMERIC}
		), LIN_BINS (BIN_NUMBER, LOW_BOUND, HIGH_BOUND) AS (

		  SELECT
			BIN_NUMBER,
			(SELECT ((OVERALL_VALUE_RANGE / #{binCount, jdbcType=NUMERIC}) * (BIN_NUMBER - 1)) + OVERALL_MIN_VALUE FROM CONST_DATA) AS LOW_BOUND,
			CASE
			WHEN BIN_NUMBER = #{binCount, jdbcType=NUMERIC} THEN (SELECT OVERALL_MAX_VALUE FROM CONST_DATA) 
			ELSE (SELECT ((OVERALL_VALUE_RANGE / #{binCount, jdbcType=NUMERIC}) * BIN_NUMBER) + OVERALL_MIN_VALUE FROM CONST_DATA) 
			END AS HIGH_BOUND
		  FROM INT_BINS
		  ORDER BY BIN_NUMBER
		), LOG_BINS (BIN_NUMBER, LOW_BOUND, HIGH_BOUND) AS (
		  SELECT 0 BIN_NUMBER, 0 LOW_BOUND, (SELECT MIN_LOG_BIN_VALUE FROM CONST) HIGH_BOUND FROM DUAL
		  UNION ALL
		  SELECT
			BIN_NUMBER,
			CASE WHEN BIN_NUMBER = 1 THEN (SELECT GREATEST(OVERALL_MIN_VALUE, (SELECT MIN_LOG_BIN_VALUE FROM CONST)) FROM CONST_DATA) ELSE POWER(10, LOG_LOW_BOUND) END AS LOW_BOUND,
			CASE WHEN BIN_NUMBER = #{binCount, jdbcType=NUMERIC} THEN (SELECT OVERALL_MAX_VALUE FROM CONST_DATA) ELSE POWER(10, LOG_HIGH_BOUND) END AS HIGH_BOUND
		  FROM (
			SELECT
			  BIN_NUMBER,
			  (SELECT (((LOG(10, OVERALL_MAX_VALUE) - LOG(10, GREATEST(OVERALL_MIN_VALUE, (SELECT MIN_LOG_BIN_VALUE FROM CONST)))) / #{binCount, jdbcType=NUMERIC}) * (BIN_NUMBER - 1)) + LOG(10, GREATEST(OVERALL_MIN_VALUE, (SELECT MIN_LOG_BIN_VALUE FROM CONST))) FROM CONST_DATA) AS LOG_LOW_BOUND,
			  (SELECT (((LOG(10, OVERALL_MAX_VALUE) - LOG(10, GREATEST(OVERALL_MIN_VALUE, (SELECT MIN_LOG_BIN_VALUE FROM CONST)))) / #{binCount, jdbcType=NUMERIC}) * BIN_NUMBER) + LOG(10, GREATEST(OVERALL_MIN_VALUE, (SELECT MIN_LOG_BIN_VALUE FROM CONST))) FROM CONST_DATA) AS LOG_HIGH_BOUND
			FROM INT_BINS
			ORDER BY BIN_NUMBER
		  )
		)

		SELECT 
		  BIN_NUMBER,
		  SUM(IN_BIN_MINUTES) OVER (ORDER BY BIN_NUMBER DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) /
			(SELECT OVERALL_DURATION_MINUTES FROM CONST_DATA) * 100 AS CUMULATIVE_BIN_PERC,
		  CASE
			WHEN BIN_NUMBER = 1 THEN LOW_BOUND
			WHEN BIN_NUMBER = #{binCount, jdbcType=NUMERIC} THEN HIGH_BOUND
			ELSE (LOW_BOUND + HIGH_BOUND) / 2
		  END AS BIN_VALUE,
		  IN_BIN_MINUTES,
		  SUM(IN_BIN_MINUTES) OVER (ORDER BY BIN_NUMBER DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CUMULATIVE_IN_BIN_MINUTES,
		  LOW_BOUND,
		  HIGH_BOUND
		FROM (
		  SELECT
			SUM(IN_BIN_MINUTES) AS IN_BIN_MINUTES,
			BIN_NUMBER,
			MAX(LOW_BOUND) AS LOW_BOUND,
			MAX(HIGH_BOUND) AS HIGH_BOUND
		  FROM (
			SELECT
			  CASE
				WHEN data.MIN_VALUE &lt; bin.LOW_BOUND AND data.MAX_VALUE > bin.HIGH_BOUND THEN ((bin.HIGH_BOUND - bin.LOW_BOUND) / (data.MAX_VALUE - data.MIN_VALUE)) * data.DURATION_MINUTES
				WHEN data.MIN_VALUE &lt; bin.LOW_BOUND AND data.MAX_VALUE &lt;= bin.HIGH_BOUND THEN ((data.MAX_VALUE - bin.LOW_BOUND) / (data.MAX_VALUE - data.MIN_VALUE)) * data.DURATION_MINUTES
				WHEN data.MIN_VALUE &lt; bin.HIGH_BOUND AND data.MAX_VALUE > bin.HIGH_BOUND THEN ((bin.HIGH_BOUND - data.MIN_VALUE) / (data.MAX_VALUE - data.MIN_VALUE)) * data.DURATION_MINUTES
				ELSE data.DURATION_MINUTES
			  END AS IN_BIN_MINUTES,
			  MIN_VALUE, MAX_VALUE, LOW_BOUND, HIGH_BOUND, DURATION_MINUTES,
			  START_VALUE, END_VALUE, START_TIME, END_TIME, BIN_NUMBER, GAP_MINUTES
			FROM LOG_BINS bin INNER JOIN CLEAN_MTI_DATA data ON
			  (data.MIN_VALUE &lt; bin.HIGH_BOUND AND data.MAX_VALUE > bin.LOW_BOUND) 
			  OR (data.MIN_VALUE = data.MAX_VALUE AND data.MIN_VALUE = bin.LOW_BOUND) 
			  OR (data.MIN_VALUE = bin.HIGH_BOUND AND bin.BIN_NUMBER = #{binCount, jdbcType=NUMERIC}) 
			ORDER BY bin.BIN_NUMBER, START_TIME
		  ) 
		  GROUP BY BIN_NUMBER
		  )
		  ORDER BY BIN_NUMBER 
		)
		ORDER BY BIN_NUMBER
	</select>	
</mapper>